import config from "./LayoutVariables";
import styled from "styled-components";
import React from "react";
import PropTypes from "prop-types";

function parseStringToNumber(string) {
    string = string.trim();

    if (string.slice(-2) === "px") {
        return parseInt(string);
    } else if (string.slice(-1) === "%") {
        return (parseInt(string) / 100) * document.body.clientWidth;
    } else {
        throw `Wrong value '${string}' in LayoutVariables`;
    }
}

/**
 * Parse breakpoints
 *
 * NAMING CONVENTION:
 *
 * BreakpointMap:
 *
 * {
 *      "breakpoint name": any
 *      200: any
 * }
 *
 * BreakpointArray (sorted!!!):
 *
 * [BreakpointEntry, BreakpointEntry, ...]
 *
 * BreakpointEntry:
 *
 * {
 *      breakpoint: Int (breakpoint value),
 *      ... props ...
 *  }
 *
 *
 *
 */

let BreakpointsCSS = config.breakpoints;
let Breakpoints = {};
let BreakpointsArray = [];

Object.keys(BreakpointsCSS).forEach(name => {
    Breakpoints[name] = parseInt(BreakpointsCSS[name]);
    BreakpointsArray.push({
        breakpoint: Breakpoints[name],
        name: name
    });
});

BreakpointsArray.sort((x, y) => x.breakpoint - y.breakpoint);

/**
 * Create breakpoint map with container / grid CSS values (margin, width, gutter).
 */

class LayoutParams {
    // from CSS
    constructor(maxWidth, margin, gutter, colNumber) {
        this._maxWidth = maxWidth;
        this._margin = margin;
        this._gutter = gutter;
        this._colNumber = colNumber;

        if (maxWidth) {
            this.css = {
                container: maxWidth,
                margin: `calc(50% - ${maxWidth}/2)`,
                gutter: gutter
            };
        } else {
            this.css = {
                container: `calc(100% - ${margin} - ${margin})`,
                margin: margin,
                gutter: gutter
            };
        }
    }

    get container() {
        if (this._maxWidth) {
            return parseStringToNumber(this._maxWidth);
        } else {
            return (
                document.body.clientWidth -
                2 * parseStringToNumber(this._margin)
            );
        }
    }

    get margin() {
        if (this._maxWidth) {
            return (
                (document.body.clientWidth -
                    parseStringToNumber(this._maxWidth)) /
                2
            );
        } else {
            return parseStringToNumber(this._margin);
        }
    }

    get colNumber() {
        return this._colNumber;
    }

    get gutter() {
        return parseStringToNumber(this._gutter);
    }

    get col() {
        return (
            (this.container - (this.colNumber - 1) * this.gutter) /
            this.colNumber
        );
    }

    cols(n) {
        return this.col * n + this.gutter * (n - 1);
    }
}

let layoutParamsBreakpointMap = {};

BreakpointsArray.forEach(breakpointEntry => {
    layoutParamsBreakpointMap[breakpointEntry.name] = new LayoutParams(
        config["container-max-width"][breakpointEntry.name],
        config["margins"][breakpointEntry.name],
        config["gutters"][breakpointEntry.name],
        config.columns
    );
});

/**
 * Breakpoint iterator helper
 */
function breakpointMapForEach(breakpointsMap, callback) {
    let breakpointStringValues = Object.keys(breakpointsMap);
    let breakpointsArray = [];

    breakpointStringValues.forEach(name => {
        if (typeof name === "string" && isNaN(parseInt(name))) {
            breakpointsArray.push({
                breakpoint: Breakpoints[name],
                content: breakpointsMap[name]
            });
        } else {
            breakpointsArray.push({
                breakpoint: parseInt(name),
                content: breakpointsMap[name]
            });
        }
    });

    breakpointsArray.sort((x, y) => x.breakpoint - y.breakpoint);

    let i = 0; // index of breakpoints form map
    let j = 0; // index of canonical breakpoints
    let minBreakpoint = 0;
    let newBreakpoint;

    let canonicalBreakpointEntry, breakpointEntry;
    let activeCanonicalBreakpointEntry = null;
    let activeBreakpointEntry = null;

    function run() {
        if (newBreakpoint !== minBreakpoint) {
            callback(
                activeBreakpointEntry ? activeBreakpointEntry.content : null,
                {
                    minWidth: minBreakpoint,
                    maxWidth: newBreakpoint === null ? null : newBreakpoint - 1,
                    layoutParams:
                        layoutParamsBreakpointMap[
                            activeCanonicalBreakpointEntry.name
                        ]
                }
            );
        }
    }

    while (1) {
        breakpointEntry = breakpointsArray[i];
        canonicalBreakpointEntry = BreakpointsArray[j];

        if (
            breakpointEntry === undefined &&
            canonicalBreakpointEntry === undefined
        ) {
            newBreakpoint = null;
            run();
            break;
        } else if (breakpointEntry === undefined) {
            newBreakpoint = canonicalBreakpointEntry.breakpoint;
            run();
            activeCanonicalBreakpointEntry = canonicalBreakpointEntry;
            j++;
        } else if (canonicalBreakpointEntry === undefined) {
            newBreakpoint = breakpointEntry.breakpoint;
            run();
            activeBreakpointEntry = breakpointEntry;
            i++;
        } else if (
            breakpointEntry.breakpoint >= canonicalBreakpointEntry.breakpoint
        ) {
            newBreakpoint = canonicalBreakpointEntry.breakpoint;
            run();
            activeCanonicalBreakpointEntry = canonicalBreakpointEntry;
            j++;
        } else {
            newBreakpoint = breakpointEntry.breakpoint;
            run();
            activeBreakpointEntry = breakpointEntry;
            i++;
        }

        minBreakpoint = newBreakpoint;
    }
}

function generateCSSForBreakpointMap(breakpointsMap, callback) {
    let style = "";

    breakpointMapForEach(
        breakpointsMap,
        (content, { minWidth, maxWidth, layoutParams }) => {
            style += `
            @media only screen and (min-width: ${minWidth}px) ${
                maxWidth ? `and (max-width: ${maxWidth}px)` : ""
            } {
                ${callback(content, { minWidth, maxWidth, layoutParams })}
            }
        `;
        }
    );

    return style;
}

function generateCSSForBreakpoints(callback) {
    let style = "";

    breakpointMapForEach(
        layoutParamsBreakpointMap,
        (content, { minWidth, maxWidth, layoutParams }) => {
            style += `
            @media only screen and (min-width: ${minWidth}px) ${
                maxWidth ? `and (max-width: ${maxWidth}px)` : ""
            } {
                ${callback({ minWidth, maxWidth, layoutParams })}
            }
        `;
        }
    );

    return style;
}

/**
 * Layout calculations
 */

LayoutParams.active = () => {
    let result;

    breakpointMapForEach(
        layoutParamsBreakpointMap,
        (layoutParams, { minWidth, maxWidth }) => {
            if (
                minWidth <= document.body.clientWidth &&
                (maxWidth === null || document.body.clientWidth <= maxWidth)
            ) {
                result = layoutParams;
            }
        }
    );

    return result;
};

/**
 * Styled components
 */

// Container

let containerStyles = generateCSSForBreakpointMap(
    layoutParamsBreakpointMap,
    layoutParams => `
    width: ${layoutParams.css.container};
    margin: 0 ${layoutParams.css.margin};
`
);

const Container = styled.div([containerStyles]);

// GridRow

let gridRowStyles = `
    display: flex;
    flex-wrap: wrap;
`;

gridRowStyles += generateCSSForBreakpointMap(
    layoutParamsBreakpointMap,
    layoutParams => `
     margin-left: calc(${layoutParams.css.gutter} / -2);
     margin-right: calc(${layoutParams.css.gutter} / -2);
`
);

const GridRow = styled.div([gridRowStyles]);

function normalizeGridItemParams(params) {
    if (typeof params === "number") {
        return {
            cols: params,
            offset: 0,
            order: 0
        };
    } else if (Array.isArray(params)) {
        return {
            cols: params[0] || 0,
            offset: params[1] || 0,
            order: params[2] || 0
        };
    }

    params.cols = params.cols || 0;
    params.offset = params.offset || 0;
    params.order = params.order || 0;

    return params;
}

// GridItem
const GridItem = function(props) {
    let style = `
        position: relative;
        width: 100%;
        min-height: 1px;
    `;

    style += generateCSSForBreakpointMap(
        props.gridParams,
        (params, { layoutParams }) => {
            params = normalizeGridItemParams(params);

            return `
        padding-left: calc(${layoutParams.css.gutter} / 2);
        padding-right: calc(${layoutParams.css.gutter} / 2);
        flex: 0 0 ${(params.cols / layoutParams.colNumber) * 100}%;
        max-width: ${(params.cols / layoutParams.colNumber) * 100}%;
        ${
            params.offset > 0
                ? `margin-left: ${(params.offset / layoutParams.colNumber) *
                      100}%;`
                : ""
        } 
        ${params.order !== 0 ? `order: ${params.order};` : ""}
        ${params.cols === 0 ? "display: none;" : ""}
        ${props.__extraStyles}
    `;
        }
    );

    const GridItem = styled.div([style]);

    return (
        <GridItem>
            {/*<div style={{ position: "relative", width: "100%" }}>*/}
            {props.children}
            {/*</div>*/}
        </GridItem>
    );
};

GridItem.propTypes = {
    gridParams: PropTypes.oneOfType([
        PropTypes.array,
        PropTypes.number,
        PropTypes.object
    ]),
    __extraStyles: PropTypes.string
};

GridItem.defaultProps = {
    __extraStyles: ""
};

const Grid = function(props) {
    return (
        <Container>
            <GridRow>
                {props.items.map((item, i) => (
                    <GridItem
                        key={i}
                        gridParams={item.gridParams}
                        __extraStyles={item.__extraStyles}
                    >
                        {item.content}
                    </GridItem>
                ))}
            </GridRow>
        </Container>
    );
};

Grid.propTypes = {
    items: PropTypes.array
};

export {
    // Breakpoints
    Breakpoints,
    BreakpointsCSS,
    BreakpointsArray,
    breakpointMapForEach,
    generateCSSForBreakpointMap,
    generateCSSForBreakpoints,
    normalizeGridItemParams,
    LayoutParams,
    Container,
    Grid
    // GridRow,
    // GridItem
};
